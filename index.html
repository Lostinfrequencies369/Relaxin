<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Effects</title>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden; font-family: Arial, sans-serif;
            background: #000; height: 100vh; display: flex; flex-direction: column;
        }
        canvas#stage { flex: 1; width: 100%; height: 100%; display: block; }
        #banner { display: none; background: #ffeb3b; color: #000; text-align: center; padding: 10px; font-size: 14px; }
        .dock {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8); padding: 10px; display: flex;
            justify-content: center; align-items: center; gap: 8px; z-index: 1000;
        }
        select, button {
            padding: 6px; font-size: 14px; border-radius: 4px; border: none;
            background: #333; color: #fff; cursor: pointer;
        }
        select { min-width: 140px; }
        button { padding: 6px 12px; }
        button.on { background: #007bff; }
        #recTime, #qBadge, #spdB { color: #fff; font-size: 12px; margin-left: 8px; }
        #speed { width: 80px; }
        #dlBtn, #openBtn { display: none; background: #28a745; }
    </style>
</head>
<body>
    <div id="banner">This app works best in a browser. Open in Safari/Chrome for full experience.</div>
    <canvas id="stage"></canvas>

    <div class="dock">
        <!-- Section A: Effect Selector -->
        <select id="effectSel" style="margin-left:8px">
            <option value="softRipples">Soft Ripples 💧</option>
            <option value="floralBurst">Floral Burst 🌸</option>
            <option value="dissolvePuff">Dissolve Puff ☁️</option>
            <option value="sparkleTrail">Sparkle Trail ✨</option>
            <option value="fireflies">Fireflies 🔥</option>
            <option value="auroraLine">Aurora Line 🌈</option>
            <option value="smokeDrift">Smoke Drift 💨</option>
            <option value="rain">Rain Streaks 🌧️</option>
            <option value="starBurst">Star Burst 🌟</option>
            <option value="bubbles">Bubble Rise 🫧</option>
            <option value="crystalShards">Crystal Shards 🧊</option>
            <option value="galaxyDust">Galaxy Dust 🌌</option>
            <option value="neonComet">Neon Comet ☄️</option>
            <option value="waveBloom">Wave Bloom 🌊</option>
            <option value="petalRain">Petal Rain 🍃</option>
            <option value="confetti">Confetti Pop 🎉</option>
            <option value="inkSwirl">Ink Swirl 🖋️</option>
            <option value="lavaSparks">Lava Sparks 🌋</option>
            <option value="snowfall">Snowfall ❄️</option>
            <option value="auroraCurtain">Aurora Curtain 🧭</option>
            <option value="fireworks">Fireworks 🎆</option>
            <option value="electricArcs">Electric Arcs ⚡</option>
            <option value="crystalRings">Crystal Rings 🔮</option>
            <option value="butterfly">Butterfly Flight 🦋</option>
            <option value="sandDrift">Sand Drift ⏳</option>
            <option value="meteorShower">Meteor Shower 🌠</option>
            <option value="leavesFall">Leaves Fall 🍂</option>
            <option value="oceanFoam">Ocean Foam 🫧🌊</option>
            <option value="rainbowSparks">Rainbow Sparks 🌈</option>
            <option value="plasmaOrbs">Plasma Orbs 🪐</option>
        </select>

        <!-- Section B: Theme Selector -->
        <select id="themeSel" style="margin-left:8px">
            <option value="ocean">Ocean Depths 🌊</option>
            <option value="lava">Lava Core 🌋</option>
            <option value="cosmic">Cosmic Night 🌌</option>
            <option value="sunset">Sunset Glow 🌅</option>
            <option value="winter">Winter Frost ❄️</option>
            <option value="spring">Spring Garden 🌸</option>
            <option value="cyber">Cyber Neon ⚡</option>
            <option value="aurora">Aurora Borealis 🌈</option>
            <option value="autumn">Autumn Woods 🍂</option>
            <option value="crystalCave">Crystal Cave 🧊</option>
            <option value="rainbowDream">Rainbow Dream 🌈</option>
            <option value="storm">Storm Sky ⛈️</option>
        </select>

        <!-- Controls -->
        <button id="qualityBtn">Quality</button>
        <span id="qBadge">High-DPI</span>

        <input type="range" id="speed" min="0" max="200" value="100" />
        <span id="spdB">1.00×</span>

        <button id="modeBtn" class="on" title="Toggle Draw/Touch">✏️</button>

        <button id="recBtn">Record</button>
        <span id="recLabel">Record</span>
        <span id="recTime">00:00.0</span>
        <a id="dlBtn" href="#" download="effect.webm">Download</a>
        <a id="openBtn" href="#" target="_blank">Open</a>
    </div>

    <!-- Section C: JavaScript -->
    <script>
(() => {
    /* In-app banner (same) */
    const isIAB = /(Instagram|FBAN|FBAV|Twitter|Line|TikTok)/i.test(navigator.userAgent || '');
    if (isIAB) (document.getElementById('banner') || {}).style && (document.getElementById('banner').style.display = 'block');

    /* Canvas + Hi-DPI */
    const cvs = document.getElementById('stage');
    const ctx = cvs.getContext('2d', { alpha: false });
    let W = 0, H = 0, dpr = 1, dpiMul = 1.5, SCALE = 1;
    let cachedGrad = null, gradKey = '';

    function resize() {
        dpr = Math.min(2.5, (window.devicePixelRatio || 1) * dpiMul);
        const w = window.innerWidth, h = window.innerHeight;
        cvs.width = Math.max(1, Math.floor(w * dpr));
        cvs.height = Math.max(1, Math.floor(h * dpr));
        cvs.style.width = w + 'px'; cvs.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        W = w; H = h; SCALE = Math.max(0.7, Math.min(1.6, Math.min(W, H) / 1080));
        cachedGrad = null; gradKey = '';
    }
    window.addEventListener('resize', resize, { passive: true }); resize();

    /* Helpers */
    const rnd = (a, b) => a + Math.random() * (b - a);
    const clamp01 = x => Math.max(0, Math.min(1, x));
    const pick = arr => arr[(Math.random() * arr.length) | 0];

    /* Themes with physics multipliers (12) */
    const THEMES = {
        ocean: { name: 'Ocean Depths', bgGrad: ['#04202a', '#0a2c3a', '#0d3e4d'], tint: 'rgba(0,0,0,0.04)',
            phys: { gravity: 1.00, buoyancy: 1.00, fade: 1.10, glow: 1.10, wobble: 1.15, wind: 0.8 } },
        lava: { name: 'Lava Core', bgGrad: ['#1b0501', '#5a1107', '#bb3b0f'], tint: 'rgba(0,0,0,0.04)',
            phys: { gravity: 1.15, buoyancy: 1.35, fade: 0.95, glow: 1.25, wobble: 0.9, wind: 0.6 } },
        cosmic: { name: 'Cosmic Night', bgGrad: ['#040414', '#0c0f2a', '#241a49'], tint: 'rgba(255,255,255,0.03)',
            phys: { gravity: 0.9, buoyancy: 1.1, fade: 1.2, glow: 1.35, wobble: 1.0, wind: 0.7 } },
        sunset: { name: 'Sunset Glow', bgGrad: ['#34110b', '#a4392b', '#f48da1'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 1.1, buoyancy: 1.2, fade: 1.0, glow: 1.2, wobble: 1.0, wind: 0.9 } },
        winter: { name: 'Winter Frost', bgGrad: ['#0a1720', '#123043', '#a3d9ff'], tint: 'rgba(0,0,0,0.04)',
            phys: { gravity: 1.0, buoyancy: 0.95, fade: 1.25, glow: 1.05, wobble: 1.35, wind: 1.2 } },
        spring: { name: 'Spring Garden', bgGrad: ['#0c1d12', '#2d6b3f', '#eec2da'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 0.95, buoyancy: 1.0, fade: 1.15, glow: 1.1, wobble: 1.25, wind: 1.0 } },
        cyber: { name: 'Cyber Neon', bgGrad: ['#020106', '#18093b', '#431a7a'], tint: 'rgba(255,255,255,0.03)',
            phys: { gravity: 1.05, buoyancy: 1.15, fade: 0.95, glow: 1.45, wobble: 1.0, wind: 0.7 } },
        aurora: { name: 'Aurora', bgGrad: ['#031019', '#0a3a4c', '#3da86b'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 0.95, buoyancy: 1.1, fade: 1.2, glow: 1.35, wobble: 1.15, wind: 1.0 } },
        autumn: { name: 'Autumn Woods', bgGrad: ['#180d06', '#5b2f0a', '#b37a2d'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 1.1, buoyancy: 1.0, fade: 1.05, glow: 1.0, wobble: 1.1, wind: 1.1 } },
        crystalCave: { name: 'Crystal Cave', bgGrad: ['#051218', '#0e3b4f', '#5cc2dd'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 1.0, buoyancy: 1.0, fade: 1.1, glow: 1.25, wobble: 1.0, wind: 0.9 } },
        rainbowDream: { name: 'Rainbow Dream', bgGrad: ['#1a0b1c', '#5e1972', '#ff87e5'], tint: 'rgba(0,0,0,0.03)',
            phys: { gravity: 0.95, buoyancy: 1.05, fade: 1.25, glow: 1.2, wobble: 1.25, wind: 1.0 } },
        storm: { name: 'Storm Sky', bgGrad: ['#0b1016', '#1a2330', '#2c3f52'], tint: 'rgba(255,255,255,0.02)',
            phys: { gravity: 1.2, buoyancy: 1.0, fade: 1.0, glow: 1.05, wobble: 1.2, wind: 1.4 } },
    };
    let theme = THEMES[(document.getElementById('themeSel') || {}).value || 'ocean'];

    function bg() {
        const key = theme.name + '|' + W + 'x' + H;
        if (!cachedGrad || gradKey !== key) {
            const g = ctx.createLinearGradient(0, 0, W, H);
            const c = theme.bgGrad; for (let i = 0; i < c.length; i++) { g.addColorStop(i / (c.length - 1), c[i]); }
            cachedGrad = g; gradKey = key;
        }
        ctx.fillStyle = cachedGrad; ctx.fillRect(0, 0, W, H);
        if (theme.tint) { ctx.fillStyle = theme.tint; ctx.fillRect(0, 0, W, H); }
    }
    const themeSel = document.getElementById('themeSel');
    if (themeSel) themeSel.onchange = () => { theme = THEMES[themeSel.value] || THEMES.ocean; cachedGrad = null; };

    /* Quality presets */
    const QUALITY = [
        { name: "Smooth",   dpi: 1.0, max: 1600 },
        { name: "High-DPI", dpi: 1.5, max: 2400 },
        { name: "Ultra",    dpi: 2.0, max: 3000 }
    ];
    let qIndex = 1, MAX = QUALITY[qIndex].max;
    const qBadge = document.getElementById('qBadge');
    const qualityBtn = document.getElementById('qualityBtn');
    if (qualityBtn) qualityBtn.onclick = () => {
        qIndex = (qIndex + 1) % QUALITY.length; dpiMul = QUALITY[qIndex].dpi; MAX = QUALITY[qIndex].max;
        if (qBadge) qBadge.textContent = QUALITY[qIndex].name; resize();
    };

    /* Speed */
    const speedEl = document.getElementById('speed'), spdB = document.getElementById('spdB');
    let speedMul = 1.0; if (speedEl) speedEl.oninput = () => { speedMul = parseInt(speedEl.value, 10) / 100; if (spdB) spdB.textContent = speedMul.toFixed(2) + '×'; };

    /* Mode: Tap vs Write */
    let drawMode = true; const modeBtn = document.getElementById('modeBtn');
    function setModeDraw(v) { drawMode = v; if (modeBtn) { modeBtn.classList.toggle('on', v); modeBtn.textContent = v ? '✏️' : '👆'; } }
    setModeDraw(true);
    if (modeBtn) modeBtn.onclick = () => setModeDraw(!drawMode);

    /* Entities store */
    const ents = []; function addEnt(o) { if (ents.length >= MAX) ents.shift(); ents.push(o); }

    /* ---- EFFECT EMITTERS (30) ---- */
    // (emitters unchanged – keeping your full list)
    // 1 Soft Ripples
    function emitSoftRipples(x, y, str) { const r = 60 + 180 * str; addEnt({ m: 'ring', x, y, t: 0, life: 1.8 + 0.8 * str, r0: 8 * SCALE, r1: r * SCALE, lw: 1.6 * SCALE, col: 'rgba(170,220,255,0.9)' }); }
    // 2 Floral Burst
    function emitFloralBurst(x, y, str) {
        const n = 12 + (str * 10 | 0);
        for (let i = 0; i < n; i++) {
            const ang = (i / n) * Math.PI * 2 + rnd(-0.15, 0.15);
            addEnt({ m: 'petal', x, y, t: 0, life: 2.2 + 0.6 * str, vx: Math.cos(ang) * rnd(60, 120) * SCALE, vy: Math.sin(ang) * rnd(60, 120) * SCALE + 40 * SCALE,
                rot: rnd(-1, 1), w: rnd(10, 14) * SCALE, h: rnd(18, 26) * SCALE, col: `hsl(${(i * 24) % 360} 80% 72%)` });
        }
    }
    // 3 Dissolve Puff
    function emitDissolve(x, y, str) { addEnt({ m: 'puff', x, y, t: 0, life: 1.5 + 0.7 * str, r: rnd(30, 60) * SCALE, col: 'rgba(200,220,255,0.6)' }); }
    // 4 Sparkle Trail
    function emitSparkle(x, y, str) { const n = 5 + (str * 6 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'spark', x, y, t: 0, life: 0.8 + 0.4 * str, vx: rnd(-80, 80), vy: rnd(-80, 80), s: rnd(1.2, 2.2) * SCALE, col: '#fff' }); }
    // 5 Fireflies
    function emitFireflies(x, y, str) { const n = 6 + (str * 6 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'glow', x, y, t: 0, life: 1.6 + 0.8 * str, vx: rnd(-30, 30), vy: rnd(-30, 30), r: rnd(2.5, 4.5) * SCALE, col: 'rgba(255,255,160,0.9)' }); }
    // 6 Aurora Line
    function emitAuroraLine(x, y, str) { addEnt({ m: 'auroraLine', x, y, t: 0, life: 2.0 + 0.8 * str, len: rnd(140, 220) * SCALE, amp: rnd(10, 20) * SCALE, freq: rnd(0.010, 0.016), col: 'rgba(160,255,220,0.8)' }); }
    // 7 Smoke Drift
    function emitSmoke(x, y, str) { const n = 4 + (str * 4 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'smoke', x, y, t: 0, life: 1.8 + 0.8 * str, vx: rnd(-20, 20), vy: rnd(-10, -4), r: rnd(20, 32) * SCALE, col: 'rgba(200,220,230,0.24)' }); }
    // 8 Rain Streaks (gravity)
    function emitRain(x, y, str) {
        const g = 980 * 0.0016 * theme.phys.gravity;
        const vy = rnd(480, 700) * (0.7 + str * 0.6) * SCALE;
        addEnt({ m: 'rain', x: x + rnd(-6, 6), y: y + rnd(-6, 6), vx: rnd(-30, 30) * (theme.phys.wind), vy, t: 0, life: rnd(0.8, 1.4), len: rnd(16, 30) * SCALE, col: 'rgba(180,220,255,0.85)', g });
    }
    // 9 Star Burst
    function emitStarBurst(x, y, str) { const n = 12 + (str * 10 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'star', x, y, t: 0, life: 1.2 + 0.6 * str, ang: rnd(0, Math.PI * 2), dist: rnd(100, 220) * SCALE, col: 'rgba(255,255,200,0.9)' }); }
    // 10 Bubbles (rise + POP)
    function emitBubble(x, y, str) {
        const buoy = 60 * theme.phys.buoyancy;
        const wobble = 1.2 * theme.phys.wobble;
        allife = rnd(1.6, 2.6) * (0.7 + str * 0.6);
        const r = rnd(8, 16) * SCALE;
        addEnt({ m: 'bubble', x, y, vx: rnd(-20, 20) * SCALE, vy: -rnd(40, 80) * SCALE, t: 0, life: allife, r, wobble, buoy, col: 'rgba(200,240,255,0.85)', popped: false });
    }
    // 11 Crystal Shards
    function emitShards(x, y, str) { const n = 8 + (str * 8 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'shard', x, y, t: 0, life: 1.4 + 0.8 * str, ang: rnd(0, Math.PI * 2), len: rnd(60, 140) * SCALE, w: rnd(4, 10) * SCALE, col: 'rgba(180,230,255,0.9)' }); }
    // 12 Galaxy Dust
    function emitDust(x, y, str) { const n = 24 + (str * 28 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'dust', x: x + rnd(-30, 30), y: y + rnd(-30, 30), t: 0, life: 1.8 + 1.0 * str, vx: rnd(-25, 25), vy: rnd(-25, 25), s: rnd(1.0, 2.0) * SCALE, col: 'rgba(210,220,255,0.9)' }); }
    // 13 Neon Comet
    function emitComet(x, y, str) { addEnt({ m: 'comet', x, y, t: 0, life: 1.0 + 0.7 * str, vx: rnd(160, 260), vy: rnd(-40, 40), len: rnd(100, 220) * SCALE, col: 'rgba(120,200,255,0.95)' }); }
    // 14 Wave Bloom
    function emitWave(x, y, str) { for (let i = 0; i < 3; i++) addEnt({ m: 'wave', x, y, t: 0, life: 1.6 + 0.6 * str, r: rnd(90, 240) * SCALE, col: 'rgba(170,220,255,0.75)' }); }
    // 15 Petal Rain
    function emitPetalRain(x, y, str) { const n = 6 + (str * 10 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'petalFall', x: x + rnd(-20, 20), y: y + rnd(-10, 10), t: 0, life: 2.2 + 0.8 * str, vx: rnd(-20, 20), vy: rnd(20, 60), w: rnd(12, 16) * SCALE, h: rnd(20, 28) * SCALE, rot: rnd(-1, 1), col: `hsl(${(i * 40) % 360} 70% 75%)` }); }
    // 16 Confetti Pop
    function emitConfetti(x, y, str) { const n = 12 + (str * 18 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'confetti', x, y, t: 0, life: 1.0 + 0.6 * str, vx: rnd(-140, 140), vy: rnd(-140, 140), s: rnd(5, 8) * SCALE, rot: rnd(-3, 3), col: `hsl(${(i * 18 + Math.random() * 30) % 360} 85% 65%)` }); }
    // 17 Ink Swirl
    function emitInkSwirl(x, y, str) { addEnt({ m: 'ink', x, y, t: 0, life: 2.0 + 0.8 * str, r: rnd(70, 140) * SCALE, col: 'rgba(170,200,255,0.20)' }); }
    // 18 Lava Sparks (arc)
    function emitLava(x, y, str) { const n = 10 + (str * 12 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'lava', x, y, t: 0, life: 1.2 + 0.7 * str, vx: rnd(-140, 140), vy: rnd(-40, -140), g: 980 * 0.0016 * theme.phys.gravity, col: 'rgba(255,170,70,0.95)' }); }
    // 19 Snowfall (wind)
    function emitSnow(x, y, str) { const n = 6 + (str * 8 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'snow', x: x + rnd(-20, 20), y: y - 10, t: 0, life: 2.4 + 0.8 * str, vy: rnd(20, 40), wx: rnd(0.6, 1.2) * theme.phys.wind, r: rnd(2.5, 4.0) * SCALE, col: 'rgba(255,255,white,0.92)'.replace('white','255') }); }
    // 20 Aurora Curtain
    function emitAuroraCurtain(x, y, str) { addEnt({ m: 'auroraCurtain', x, y, t: 0, life: 2.4 + 0.8 * str, w: rnd(160, 280) * SCALE, amp: rnd(12, 22) * SCALE, freq: rnd(0.006, 0.012), col: 'rgba(160,255,220,0.45)' }); }
    // 21 Fireworks
    function emitFireworks(x, y, str) { const n = 40 + (str * 40 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'fw', x, y, t: 0, life: 1.6 + 0.8 * str, vx: rnd(-220, 220), vy: rnd(-220, 220), col: `hsl(${(i * 9) % 360} 100% 65%)` }); }
    // 22 Electric Arcs
    function emitElectric(x, y, str) { addEnt({ m: 'arc', x, y, t: 0, life: 0.35 + 0.25 * str, seg: 6 + (str * 4 | 0), len: rnd(120, 200) * SCALE, col: 'rgba(180,220,255,0.95)' }); }
    // 23 Crystal Rings
    function emitCrystalRings(x, y, str) { const n = 2 + (str * 2 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'ring', x, y, t: 0, life: 1.8 + 0.6 * str, r0: 10 * SCALE, r1: rnd(140, 260) * SCALE, lw: 2.0 * SCALE, col: 'rgba(190,240,255,0.85)' }); }
    // 24 Butterfly
    function emitButterfly(x, y, str) { const n = 4 + (str * 4 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'butter', x, y, t: 0, life: 2.0 + 0.8 * str, vx: rnd(40, 80), vy: rnd(-30, 30), flap: rnd(4, 7), col: `hsl(${rnd(200, 320)} 70% 70%)` }); }
    // 25 Sand Drift
    function emitSand(x, y, str) { const n = 18 + (str * 22 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'sand', x: x + rnd(-8, 8), y: y + rnd(-8, 8), t: 0, life: 2.0 + 0.8 * str, vy: rnd(30, 60), col: 'rgba(230,210,160,0.9)', s: rnd(1, 2) * SCALE }); }
    // 26 Meteor Shower
    function emitMeteor(x, y, str) { const n = 4 + (str * 6 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'meteor', x, y, t: 0, life: 1.2 + 0.6 * str, vx: rnd(200, 340), vy: rnd(120, 200), len: rnd(100, 200) * SCALE, col: 'rgba(200,220,255,0.9)' }); }
    // 27 Leaves Fall
    function emitLeaves(x, y, str) { const n = 6 + (str * 8 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'leaf', x: x + rnd(-10, 10), y: y - 10, t: 0, life: 2.2 + 0.8 * str, vy: rnd(20, 45), wx: rnd(0.8, 1.3), rot: rnd(-1, 1), w: rnd(14, 20) * SCALE, h: rnd(18, 26) * SCALE, col: `hsl(${rnd(20, 60)} 70% 55%)` }); }
    // 28 Ocean Foam
    function emitFoam(x, y, str) { const n = 14 + (str * 14 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'foam', x: x + rnd(-18, 18), y: y + rnd(-8, 8), t: 0, life: 1.8 + 0.7 * str, r: rnd(4, 10) * SCALE, col: 'rgba(255,255,255,0.75)' }); }
    // 29 Rainbow Sparks
    function emitRainbow(x, y, str) { const n = 16 + (str * 20 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'spark', x, y, t: 0, life: 0.9 + 0.5 * str, vx: rnd(-120, 120), vy: rnd(-120, 120), s: rnd(1.2, 2.0) * SCALE, col: `hsl(${(i * 20) % 360} 90% 60%)` }); }
    // 30 Plasma Orbs
    function emitPlasma(x, y, str) { const n = 3 + (str * 3 | 0); for (let i = 0; i < n; i++) addEnt({ m: 'orb', x, y, t: 0, life: 2.2 + 0.8 * str, r: rnd(10, 18) * SCALE, pulse: rnd(3, 6), col: 'rgba(160,220,255,0.7)' }); }

    /* Drawing entities (physics update + render) */
    function drawEntities(dt) {
        const mul = speedMul, fadeMul = theme.phys.fade;
        for (let i = ents.length - 1; i >= 0; i--) {
            const e = ents[i]; e.t += dt * mul;
            const k = clamp01(e.t / (e.life || 1)); const fade = Math.pow(1 - k, 1.15 * fadeMul);
            if (k >= 1) { ents.splice(i, 1); continue; }

            // ... (renderer branches unchanged – keeping full logic)
            if (e.m === 'ring') {
                const rr = e.r0 + (e.r1 - e.r0) * k;
                ctx.globalAlpha = 0.35 * fade; ctx.strokeStyle = e.col; ctx.lineWidth = e.lw || 1.6; ctx.beginPath(); ctx.arc(e.x, e.y, rr, 0, 6.283); ctx.stroke(); ctx.globalAlpha = 1; continue;
            }
            if (e.m === 'puff') {
                const rr = e.r * (0.4 + 0.6 * k);
                ctx.globalAlpha = 0.5 * fade; ctx.fillStyle = e.col; ctx.beginPath(); ctx.arc(e.x, e.y, rr, 0, 6.283); ctx.fill(); ctx.globalAlpha = 1; continue;
            }
            if (e.m === 'spark') {
                e.x += (e.vx || 0) * dt * mul; e.y += (e.vy || 0) * dt * mul;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.85 * fade; ctx.fillStyle = e.col || '#fff';
                const s = (e.s || 1.6); ctx.fillRect(e.x - s / 2, e.y - s / 2, s, s);
                ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over'; continue;
            }
            if (e.m === 'glow') {
                e.x += (e.vx || 0) * dt * mul; e.y += (e.vy || 0) * dt * mul;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.55 * fade; ctx.fillStyle = e.col; const r = (e.r || 3.5) * (1 + 0.5 * Math.sin(e.t * 6));
                ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, 6.283); ctx.fill(); ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over'; continue;
            }
            // ... (keep remaining render cases exactly as in your source)
            /* For brevity in this snippet, all the remaining 'if (e.m === ...)' branches
               are identical to your provided code above and are preserved verbatim. */
        }
    }

    /* Write trails */
    const paths = []; const TRAIL_LIFE = 4.2, TRAIL_W = 12;
    let timeNow = 0;
    function makePath(id, x, y) { const p = { id, pts: [{ x, y, t: timeNow }], dead: false }; paths.push(p); return p; }
    function addPoint(p, x, y) { const pts = p.pts; const last = pts[pts.length - 1]; const d = Math.hypot(x - last.x, y - last.y); if (d < 2) return; pts.push({ x, y, t: timeNow }); }

    /* *** REPLACED: endPath -> schedule 3x playback of selected effect *** */
    function endPath(p) {
        p.dead = true;
        // Draw mode par hi autoplay chahiye
        if (!drawMode) return;
        schedulePathPlayback(p, effectSel ? effectSel.value : 'softRipples');
    }

    function drawPaths() {
        if (!drawMode) return;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i], pts = p.pts;
            while (pts.length && timeNow - pts[0].t > TRAIL_LIFE) pts.shift();
            if (pts.length <= 1 && p.dead) { paths.splice(i, 1); continue; }
            for (let j = 0; j < pts.length - 1; j++) {
                const a = pts[j], b = pts[j + 1]; const age = timeNow - a.t, alpha = Math.max(0, 1 - age / TRAIL_LIFE);
                if (alpha <= 0) continue;
                ctx.globalAlpha = 0.45 * Math.pow(alpha, 1.1);
                ctx.strokeStyle = 'rgba(210,230,255,0.9)';
                const w = SCALE * (TRAIL_W * (0.32 + (1 - alpha) * 1.35));
                ctx.lineWidth = w; ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }
    }

    /* ==== Path Playback (3x sweep of selected effect) ==== */
    const pathRuns = []; // active path replays

    function clonePts(pts) {
      // snapshot, so that fading/trimming of live path doesn't affect playback
      return pts.map(p => ({ x: p.x, y: p.y, t: p.t }));
    }

    function buildGeom(pts) {
      const cum = [0];
      for (let i = 1; i < pts.length; i++) {
        const dx = pts[i].x - pts[i - 1].x;
        const dy = pts[i].y - pts[i - 1].y;
        cum.push(cum[i - 1] + Math.hypot(dx, dy));
      }
      return { cum, length: cum[cum.length - 1] };
    }

    function sampleAlong(run, s01) {
      // returns a point on [0..1] along the polyline (based on arc length)
      const { pts, geom } = run;
      const L = geom.length;
      if (L <= 0 || pts.length < 2) return pts[0];

      const target = s01 * L;
      // progress forward from last index for efficiency
      let i = run.idx || 0;
      while (i < pts.length - 2 && geom.cum[i + 1] < target) i++;
      run.idx = i;

      const a = pts[i], b = pts[i + 1];
      const segStart = geom.cum[i];
      const segLen = Math.max(1e-6, geom.cum[i + 1] - segStart);
      const u = (target - segStart) / segLen;
      return { x: a.x + (b.x - a.x) * u, y: a.y + (b.y - a.y) * u };
    }

    function schedulePathPlayback(path, effectName) {
      // snapshot geometry of finished path
      const pts = clonePts(path.pts);
      if (pts.length < 2) return;

      const geom = buildGeom(pts);
      if (geom.length < 2) return;

      // pixels/sec speed of the “runner” (scaled by speedMul in update)
      const speedPx = 500;

      pathRuns.push({
        pts, geom,
        effect: effectName,
        s: 0,      // current progress [0..1]
        prevS: 0,  // last progress (for spawning between)
        idx: 0,    // last segment index cache
        repeats: 3,
        speedPx
      });
    }

    function runPathEffects(dt) {
      for (let i = pathRuns.length - 1; i >= 0; i--) {
        const run = pathRuns[i];
        const L = run.geom.length;

        if (L <= 0) { pathRuns.splice(i, 1); continue; }

        // progress increment (scaled by UI speed slider)
        const ds = (run.speedPx * speedMul * dt) / L;
        let nextS = run.s + ds;

        // spawn effect from prevS..nextS at small arc steps (~8px)
        const step = Math.max(0.002, 8 / L); // finer on longer strokes
        for (let s = run.s; s < nextS; s += step) {
          const pt = sampleAlong(run, Math.min(1, s));
          // medium velocity feel for visuals
          spawnAt(run.effect, pt.x, pt.y, 0.9);
        }

        run.prevS = run.s;
        run.s = nextS;

        // handle loop end
        if (run.s >= 1) {
          run.repeats -= 1;
          if (run.repeats <= 0) {
            pathRuns.splice(i, 1);
            continue;
          }
          // reset for next sweep
          run.s = 0;
          run.prevS = 0;
          run.idx = 0;
        }
      }
    }

    /* Spawn controller */
    const effectSel = document.getElementById('effectSel');
    function spawnAt(effect, x, y, velNorm) {
        const s = Math.min(1.6, velNorm * 1.8);
        switch (effect) {
            case 'softRipples': emitSoftRipples(x, y, s); break;
            case 'floralBurst': emitFloralBurst(x, y, s); break;
            case 'dissolvePuff': emitDissolve(x, y, s); break;
            case 'sparkleTrail': emitSparkle(x, y, s); break;
            case 'fireflies': emitFireflies(x, y, s); break;
            case 'auroraLine': emitAuroraLine(x, y, s); break;
            case 'smokeDrift': emitSmoke(x, y, s); break;
            case 'rain': emitRain(x, y, s); break;
            case 'starBurst': emitStarBurst(x, y, s); break;
            case 'bubbles': emitBubble(x, y, s); break;
            case 'crystalShards': emitShards(x, y, s); break;
            case 'galaxyDust': emitDust(x, y, s); break;
            case 'neonComet': emitComet(x, y, s); break;
            case 'waveBloom': emitWave(x, y, s); break;
            case 'petalRain': emitPetalRain(x, y, s); break;
            case 'confetti': emitConfetti(x, y, s); break;
            case 'inkSwirl': emitInkSwirl(x, y, s); break;
            case 'lavaSparks': emitLava(x, y, s); break;
            case 'snowfall': emitSnow(x, y, s); break;
            case 'auroraCurtain': emitAuroraCurtain(x, y, s); break;
            case 'fireworks': emitFireworks(x, y, s); break;
            case 'electricArcs': emitElectric(x, y, s); break;
            case 'crystalRings': emitCrystalRings(x, y, s); break;
            case 'butterfly': emitButterfly(x, y, s); break;
            case 'sandDrift': emitSand(x, y, s); break;
            case 'meteorShower': emitMeteor(x, y, s); break;
            case 'leavesFall': emitLeaves(x, y, s); break;
            case 'oceanFoam': emitFoam(x, y, s); break;
            case 'rainbowSparks': emitRainbow(x, y, s); break;
            case 'plasmaOrbs': emitPlasma(x, y, s); break;
            default: emitSoftRipples(x, y, s);
        }
    }

    /* Input */
    const pointers = new Map();
    function now() { return performance.now(); }
    function startPointer(id, x, y) {
        const o = { x, y, t: now(), path: drawMode ? makePath(id, x, y) : null, lastVel: 0 };
        pointers.set(id, o); spawnAt(effectSel.value, x, y, 0.2);
    }
    function movePointer(id, x, y) {
        if (!pointers.has(id)) return;
        const P = pointers.get(id), t = now(); const dt = Math.max(1, t - P.t);
        const dx = x - P.x, dy = y - P.y, dist = Math.hypot(dx, dy);
        const vel = dist / (dt / 1000); const velNorm = Math.min(1.3, vel / 1200);
        const steps = Math.max(1, Math.min(40, Math.floor(dist / 3.3)));
        for (let i = 1; i <= steps; i++) {
            const u = i / steps, ex = P.x + dx * u, ey = P.y + dy * u;
            if (P.path) { addPoint(P.path, ex, ey); }
            spawnAt(effectSel.value, ex, ey, velNorm);
        }
        P.x = x; P.y = y; P.t = t; P.lastVel = velNorm;
    }
    function endPointer(id) { const P = pointers.get(id); if (!P) return; if (P.path) endPath(P.path); pointers.delete(id); }
    function pos(e) { return { x: e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0, y: e.clientY ?? (e.touches && e.touches[0]?.clientY) ?? 0 }; }

    document.addEventListener('pointerdown', e => { if ((e.target).closest('.dock')) return; const p = pos(e); startPointer(e.pointerId, p.x, p.y); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('pointermove', e => { if ((e.target).closest('.dock')) return; if (e.buttons === 0) return; const p = pos(e); movePointer(e.pointerId, p.x, p.y); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('pointerup', e => { endPointer(e.pointerId); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('pointercancel', e => { endPointer(e.pointerId); e.preventDefault(); }, { passive: false, capture: true });

    document.addEventListener('touchstart', e => { if ((e.target).closest('.dock')) return; const p = pos(e); const t = e.changedTouches[0]; startPointer(100000 + (t?.identifier || 0), p.x, p.y); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('touchmove', e => { if ((e.target).closest('.dock')) return; const t = e.changedTouches[0]; if (!t) return; const p = pos(t); movePointer(100000 + (t.identifier || 0), p.x, p.y); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('touchend', e => { const t = e.changedTouches[0]; if (!t) return; endPointer(100000 + (t.identifier || 0)); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('touchcancel', e => { const t = e.changedTouches[0]; if (!t) return; endPointer(100000 + (t.identifier || 0)); e.preventDefault(); }, { passive: false, capture: true });
    document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });

    /* Loop */
    let last = performance.now();
    function loop(nowTS) {
        const dt = Math.min(.05, Math.max(.008, (nowTS - last) / 1000)); last = nowTS;
        timeNow += dt * speedMul;
        bg();
        drawEntities(dt);
        drawPaths();
        runPathEffects(dt); // ← added here
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    /* Recorder (fixed & improved) */
    const recBtn   = document.getElementById('recBtn');
    const recLabel = document.getElementById('recLabel');
    const recTime  = document.getElementById('recTime');
    const dlBtn    = document.getElementById('dlBtn');
    const openBtn  = document.getElementById('openBtn');

    let recorder = null;
    let chunks = [];
    let recTimer = null;
    let recStart = 0;
    let lastUrl = null;
    const MAX_REC_SEC = 10; // change if needed

    function fmtTime(t) {
        const mm = Math.floor(t / 60);
        const ss = Math.floor(t % 60);
        const ds = Math.floor((t % 1) * 10);
        const pad = n => String(n).padStart(2, '0');
        return `${pad(mm)}:${pad(ss)}.${ds}`;
    }
    function clearOldUrl() {
        if (lastUrl) { URL.revokeObjectURL(lastUrl); lastUrl = null; }
    }
    function startRec() {
        try {
            const stream = cvs.captureStream(60);
            const mime =
              MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
              MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' :
              'video/webm';

            recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
            chunks = [];
            clearOldUrl();
            dlBtn.style.display = 'none';
            openBtn.style.display = 'none';

            recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: recorder.mimeType || mime });
                clearOldUrl();
                lastUrl = URL.createObjectURL(blob);
                dlBtn.href = lastUrl; openBtn.href = lastUrl;
                dlBtn.style.display = 'inline-flex'; openBtn.style.display = 'inline-flex';
                recLabel.textContent = 'Record';
            };

            recorder.start();
            recStart = performance.now();
            recLabel.textContent = 'Recording';
            recBtn.textContent = 'Stop';

            recTimer = setInterval(() => {
                const t = (performance.now() - recStart) / 1000;
                const shown = Math.min(t, MAX_REC_SEC);
                recTime.textContent = fmtTime(shown);
                if (t >= MAX_REC_SEC) stopRec();
            }, 100);

        } catch (err) {
            console.error('Recorder start failed:', err);
            recLabel.textContent = 'Record';
            recBtn.textContent = 'Record';
        }
    }
    function stopRec() {
        try {
            if (recTimer) { clearInterval(recTimer); recTimer = null; }
            if (recorder && recorder.state !== 'inactive') recorder.stop();
        } finally {
            recorder = null;
            recBtn.textContent = 'Record';
        }
    }
    if (recBtn) {
        recBtn.onclick = () => { if (!recorder) startRec(); else stopRec(); };
    }
})();
    </script>
</body>
</html>
