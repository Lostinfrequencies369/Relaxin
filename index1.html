<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Canvas Effects</title>
  <style>
    :root {
      --panel-bg: rgba(0,0,0,0.85);
      --btn-bg: #333;
      --btn-bg-on: #007bff;
      --btn-bg-ok: #28a745;
      --btn-bg-hover: #555;
      --txt: #fff;
      --warn: #ffeb3b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0; padding:0; overflow:hidden;
      font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
      background:#000; display:flex; flex-direction:column;
      touch-action:none; /* prevent pinch/double-tap zoom */
    }
    #banner{
      display:none; background:var(--warn); color:#000; text-align:center;
      padding:.8rem; font-size:clamp(.8rem,2.5vw,1rem); line-height:1.4;
    }
    canvas#stage{
      flex:1; width:100%; height:100%; display:block;
      max-width:100vw; max-height:100vh;
    }
    .dock{
      position:fixed; left:0; right:0; bottom:0; z-index:1000;
      background:var(--panel-bg);
      padding:clamp(.5rem,2vw,.8rem);
      display:flex; flex-wrap:wrap; gap:clamp(.4rem,1.5vw,.6rem);
      justify-content:center; align-items:center;
    }
    select, button, input[type="range"], a.btn {
      font-size:clamp(.9rem,2.5vw,1.1rem);
      border:none; border-radius:.5rem; color:var(--txt);
    }
    select, button, a.btn {
      padding:clamp(.5rem,2vw,.7rem) clamp(.8rem,3vw,1rem);
      background:var(--btn-bg); cursor:pointer;
      transition: background .2s ease, transform .1s ease;
      white-space:nowrap;
    }
    select{ min-width:clamp(8rem,25vw,10rem); max-width:90vw; }
    button.on{ background:var(--btn-bg-on); }
    button:hover, select:hover, a.btn:hover{ background:var(--btn-bg-hover); transform:scale(1.05); }
    button:active, select:active, a.btn:active{ transform:scale(.95); }
    #speed{ width:clamp(4rem,15vw,6rem); height:clamp(.8rem,2.5vw,1rem); }
    #qBadge, #spdB, #recTime{ font-size:clamp(.8rem,2vw,.9rem); margin-left:.5rem; }
    #dlBtn, #openBtn { display:none; background:var(--btn-bg-ok); text-decoration:none; }
    @media (max-width:600px){
      .dock{ flex-direction:column; align-items:stretch; }
      select{ min-width:100%; }
      #speed{ width:100%; }
    }
    @media (min-resolution:192dpi){
      canvas#stage{ image-rendering: optimizeQuality; }
    }
  </style>
</head>
<body>
  <div id="banner">Best experience in Safari/Chrome (open via https or localhost for recording).</div>
  <canvas id="stage"></canvas>

  <div class="dock">
    <!-- Effect selector -->
    <select id="effectSel">
      <option value="softRipples">Soft Ripples üíß</option>
      <option value="floralBurst">Floral Burst üå∏</option>
      <option value="dissolvePuff">Dissolve Puff‚òÅÔ∏è</option>
      <option value="sparkleTrail">Sparkle Trail ‚ú®</option>
      <option value="fireflies">Fireflies üî•</option>
      <option value="auroraLine">Aurora Line üåà</option>
      <option value="smokeDrift">Smoke Drift üí®</option>
      <option value="rain">Rain Streaks üåßÔ∏è</option>
      <option value="starBurst">Star Burst üåü</option>
      <option value="bubbles">Bubble Rise ü´ß</option>
      <option value="crystalShards">Crystal Shards üßä</option>
      <option value="galaxyDust">Galaxy Dust üåå</option>
      <option value="neonComet">Neon Comet ‚òÑÔ∏è</option>
      <option value="waveBloom">Wave Bloom üåä</option>
      <option value="petalRain">Petal Rain üçÉ</option>
      <option value="confetti">Confetti Pop üéâ</option>
      <option value="inkSwirl">Ink Swirl üñãÔ∏è</option>
      <option value="lavaSparks">Lava Sparks üåã</option>
      <option value="snowfall">Snowfall ‚ùÑÔ∏è</option>
      <option value="auroraCurtain">Aurora Curtain üß≠</option>
      <option value="fireworks">Fireworks üéÜ</option>
      <option value="electricArcs">Electric Arcs ‚ö°</option>
      <option value="crystalRings">Crystal Rings üîÆ</option>
      <option value="butterfly">Butterfly Flight ü¶ã</option>
      <option value="sandDrift">Sand Drift ‚è≥</option>
      <option value="meteorShower">Meteor Shower üå†</option>
      <option value="leavesFall">Leaves Fall üçÇ</option>
      <option value="oceanFoam">Ocean Foam ü´ßüåä</option>
      <option value="rainbowSparks">Rainbow Sparks üåà</option>
      <option value="plasmaOrbs">Plasma Orbs ü™ê</option>
    </select>

    <!-- Theme selector -->
    <select id="themeSel">
      <option value="ocean">Ocean Depths üåä</option>
      <option value="lava">Lava Core üåã</option>
      <option value="cosmic">Cosmic Night üåå</option>
      <option value="sunset">Sunset Glow üåÖ</option>
      <option value="winter">Winter Frost ‚ùÑÔ∏è</option>
      <option value="spring">Spring Garden üå∏</option>
      <option value="cyber">Cyber Neon ‚ö°</option>
      <option value="aurora">Aurora Borealis üåà</option>
      <option value="autumn">Autumn Woods üçÇ</option>
      <option value="crystalCave">Crystal Cave üßä</option>
      <option value="rainbowDream">Rainbow Dream üåà</option>
      <option value="storm">Storm Sky ‚õàÔ∏è</option>
    </select>

    <button id="qualityBtn">Quality</button>
    <span id="qBadge">High-DPI</span>

    <input type="range" id="speed" min="0" max="200" value="100" />
    <span id="spdB">1.00√ó</span>

    <button id="modeBtn" class="on" title="Toggle Draw/Touch">‚úèÔ∏è</button>

    <button id="recBtn">Record</button>
    <span id="recLabel">Record</span>
    <span id="recTime">00:00.0</span>
    <a id="dlBtn" class="btn" href="#" download="effect.webm">Download</a>
    <a id="openBtn" class="btn" href="#" target="_blank">Open</a>
  </div>
<script>
(() => {
  /* Show banner inside in-app browsers */
  const isIAB = /(Instagram|FBAN|FBAV|Twitter|Line|TikTok)/i.test(navigator.userAgent || '');
  if (isIAB) {
    const bn = document.getElementById('banner');
    if (bn) bn.style.display = 'block';
  }

  /* Canvas + Hi-DPI */
  const cvs = document.getElementById('stage');
  const ctx = cvs.getContext('2d', { alpha: false });

  let W = 0, H = 0, dpr = 1, dpiMul = 1.5, SCALE = 1;
  let cachedGrad = null, gradKey = '';

  function resize() {
    dpr = Math.min(2.5, (window.devicePixelRatio || 1) * dpiMul);
    const w = window.innerWidth, h = window.innerHeight;
    cvs.width = Math.max(1, Math.floor(w * dpr));
    cvs.height = Math.max(1, Math.floor(h * dpr));
    cvs.style.width = w + 'px';
    cvs.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    W = w; H = h;
    SCALE = Math.max(0.7, Math.min(1.6, Math.min(W, H) / 1080));
    cachedGrad = null; gradKey = '';
  }
  addEventListener('resize', resize, { passive: true });
  addEventListener('orientationchange', resize, { passive: true });
  resize();

  /* Helpers */
  const rnd = (a, b) => a + Math.random() * (b - a);
  const clamp01 = x => Math.max(0, Math.min(1, x));
  const pick = arr => arr[(Math.random() * arr.length) | 0];

  /* Themes with physics multipliers */
  const THEMES = {
    ocean: { name: 'Ocean Depths',  bgGrad: ['#04202a','#0a2c3a','#0d3e4d'], tint:'rgba(0,0,0,0.04)',  phys:{ gravity:1.00, buoyancy:1.00, fade:1.10, glow:1.10, wobble:1.15, wind:0.8 } },
    lava:  { name: 'Lava Core',     bgGrad: ['#1b0501','#5a1107','#bb3b0f'], tint:'rgba(0,0,0,0.04)',  phys:{ gravity:1.15, buoyancy:1.35, fade:0.95, glow:1.25, wobble:0.90, wind:0.6 } },
    cosmic:{ name: 'Cosmic Night',  bgGrad: ['#040414','#0c0f2a','#241a49'], tint:'rgba(255,255,255,0.03)', phys:{ gravity:0.90, buoyancy:1.10, fade:1.20, glow:1.35, wobble:1.00, wind:0.7 } },
    sunset:{ name: 'Sunset Glow',   bgGrad: ['#34110b','#a4392b','#f48da1'], tint:'rgba(0,0,0,0.03)',  phys:{ gravity:1.10, buoyancy:1.20, fade:1.00, glow:1.20, wobble:1.00, wind:0.9 } },
    winter:{ name: 'Winter Frost',  bgGrad: ['#0a1720','#123043','#a3d9ff'], tint:'rgba(0,0,0,0.04)',  phys:{ gravity:1.00, buoyancy:0.95, fade:1.25, glow:1.05, wobble:1.35, wind:1.2 } },
    spring:{ name: 'Spring Garden', bgGrad: ['#0c1d12','#2d6b3f','#eec2da'], tint:'rgba(0,0,0,0.03)',  phys:{ gravity:0.95, buoyancy:1.00, fade:1.15, glow:1.10, wobble:1.25, wind:1.0 } },
    cyber: { name: 'Cyber Neon',    bgGrad: ['#020106','#18093b','#431a7a'], tint:'rgba(255,255,255,0.03)', phys:{ gravity:1.05, buoyancy:1.15, fade:0.95, glow:1.45, wobble:1.00, wind:0.7 } },
    aurora:{ name: 'Aurora',        bgGrad: ['#031019','#0a3a4c','#3da86b'], tint:'rgba(0,0,0,0.03)',  phys:{ gravity:0.95, buoyancy:1.10, fade:1.20, glow:1.35, wobble:1.15, wind:1.0 } },
    autumn:{ name: 'Autumn Woods',  bgGrad: ['#180d06','#5b2f0a','#b37a2d'], tint:'rgba(0,0,0,0.03)',  phys:{ gravity:1.10, buoyancy:1.00, fade:1.05, glow:1.00, wobble:1.10, wind:1.1 } },
    crystalCave:{ name: 'Crystal Cave', bgGrad:['#051218','#0e3b4f','#5cc2dd'], tint:'rgba(0,0,0,0.03)', phys:{ gravity:1.00, buoyancy:1.00, fade:1.10, glow:1.25, wobble:1.00, wind:0.9 } },
    rainbowDream:{ name: 'Rainbow Dream', bgGrad:['#1a0b1c','#5e1972','#ff87e5'], tint:'rgba(0,0,0,0.03)', phys:{ gravity:0.95, buoyancy:1.05, fade:1.25, glow:1.20, wobble:1.25, wind:1.0 } },
    storm: { name: 'Storm Sky',     bgGrad: ['#0b1016','#1a2330','#2c3f52'], tint:'rgba(255,255,255,0.02)', phys:{ gravity:1.20, buoyancy:1.00, fade:1.00, glow:1.05, wobble:1.20, wind:1.4 } },
  };
  let theme = THEMES[(document.getElementById('themeSel') || {}).value || 'ocean'];

  /* Background gradient draw */
  function bg() {
    const key = theme.name + '|' + W + 'x' + H;
    if (!cachedGrad || gradKey !== key) {
      const g = ctx.createLinearGradient(0, 0, W, H);
      const c = theme.bgGrad;
      for (let i = 0; i < c.length; i++) g.addColorStop(i / (c.length - 1), c[i]);
      cachedGrad = g; gradKey = key;
    }
    ctx.fillStyle = cachedGrad; ctx.fillRect(0, 0, W, H);
    if (theme.tint) { ctx.fillStyle = theme.tint; ctx.fillRect(0, 0, W, H); }
  }

  /* Theme selector hookup */
  const themeSel = document.getElementById('themeSel');
  if (themeSel) themeSel.onchange = () => { theme = THEMES[themeSel.value] || THEMES.ocean; cachedGrad = null; };

  /* Quality presets */
  const QUALITY = [
    { name: "Smooth",   dpi: 1.0, max: 1600 },
    { name: "High-DPI", dpi: 1.5, max: 2400 },
    { name: "Ultra",    dpi: 2.0, max: 3000 }
  ];
  let qIndex = 1, MAX = QUALITY[qIndex].max;
  const qBadge = document.getElementById('qBadge');
  const qualityBtn = document.getElementById('qualityBtn');
  if (qBadge) qBadge.textContent = QUALITY[qIndex].name;
  if (qualityBtn) qualityBtn.onclick = () => {
    qIndex = (qIndex + 1) % QUALITY.length;
    dpiMul = QUALITY[qIndex].dpi; MAX = QUALITY[qIndex].max;
    if (qBadge) qBadge.textContent = QUALITY[qIndex].name;
    resize();
  };

  /* Speed control */
  const speedEl = document.getElementById('speed');
  const spdB = document.getElementById('spdB');
  let speedMul = 1.0;
  if (speedEl) speedEl.oninput = () => {
    speedMul = parseInt(speedEl.value, 10) / 100;
    if (spdB) spdB.textContent = speedMul.toFixed(2) + '√ó';
  };

  /* Mode: Draw‚úèÔ∏è vs Tap üëÜ */
  let drawMode = true;
  const modeBtn = document.getElementById('modeBtn');
  function setModeDraw(v){
    drawMode = v;
    if (modeBtn){
      modeBtn.classList.toggle('on', v);
      modeBtn.textContent = v ? '‚úèÔ∏è' : 'üëÜ';
    }
  }
  setModeDraw(true);
  if (modeBtn) modeBtn.onclick = () => setModeDraw(!drawMode);

  /* Export a few things for later chunks */
  window.__CE_STATE__ = { ctx, cvs, bg, themeSel, get theme(){return theme;}, set theme(v){theme=v; cachedGrad=null;},
                          speedMulRef: () => speedMul, MAXRef: () => MAX, SCALERef: () => SCALE,
                          helpers: { rnd, clamp01, pick }, resize };
  /* Entities store */
  const ents = [];
  function addEnt(o){
    if (ents.length >= MAX) ents.shift();
    ents.push(o);
  }

  /* ---- EFFECT EMITTERS (30) ---- */
  function emitSoftRipples(x, y, str) {
    const r = 60 + 180 * str;
    addEnt({ m:'ring', x,y,t:0, life:2.2, r0:8*SCALE, r1:r*SCALE, lw:1.6*SCALE, col:'rgba(170,220,255,0.9)' });
  }
  function emitFloralBurst(x, y, str) {
    const n = 12 + (str*10|0);
    for (let i=0;i<n;i++) {
      const ang = (i/n)*Math.PI*2 + (Math.random()*0.3-0.15);
      addEnt({ m:'petal', x,y,t:0, life:2.5,
        vx:Math.cos(ang)* (40+Math.random()*80) *SCALE,
        vy:Math.sin(ang)* (40+Math.random()*80) *SCALE + 40,
        rot:(Math.random()*2-1),
        w:(10+Math.random()*4)*SCALE,
        h:(18+Math.random()*8)*SCALE,
        col:`hsl(${(i*24)%360} 80% 72%)` });
    }
  }
  function emitDissolve(x, y, str) {
    addEnt({ m:'puff', x,y,t:0, life:1.8, r:(30+Math.random()*30)*SCALE, col:'rgba(200,220,255,0.6)' });
  }
  function emitSparkle(x, y, str) {
    const n = 5 + (str*6|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'spark', x,y,t:0, life:1.0, vx:(Math.random()*160-80), vy:(Math.random()*160-80),
               s:(1.2+Math.random()*1.0)*SCALE, col:'#fff' });
  }
  function emitFireflies(x, y, str) {
    const n = 6 + (str*6|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'glow', x,y,t:0, life:2.0, vx:(Math.random()*60-30), vy:(Math.random()*60-30),
               r:(2.5+Math.random()*2.0)*SCALE, col:'rgba(255,255,160,0.9)' });
  }
  function emitAuroraLine(x, y, str) {
    addEnt({ m:'auroraLine', x,y,t:0, life:2.5, len:(140+Math.random()*80)*SCALE,
             amp:(10+Math.random()*10)*SCALE, freq:(0.010+Math.random()*0.006),
             col:'rgba(160,255,220,0.8)' });
  }
  function emitSmoke(x, y, str) {
    const n = 4 + (str*4|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'smoke', x,y,t:0, life:2.0, vx:(Math.random()*40-20), vy:-(4+Math.random()*6),
               r:(20+Math.random()*12)*SCALE, col:'rgba(200,220,230,0.24)' });
  }
  function emitRain(x, y, str) {
    const vy = (480+Math.random()*220)*(0.7+str*0.6)*SCALE;
    addEnt({ m:'rain', x:x+(Math.random()*12-6), y:y+(Math.random()*12-6),
             vx:(Math.random()*60-30)*(theme.phys.wind), vy, t:0, life:(0.8+Math.random()*0.6),
             len:(16+Math.random()*14)*SCALE, col:'rgba(180,220,255,0.85)', g:980*0.0016*theme.phys.gravity });
  }
  function emitStarBurst(x, y, str) {
    const n = 12 + (str*10|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'star', x,y,t:0, life:1.5, ang:Math.random()*Math.PI*2,
               dist:(100+Math.random()*120)*SCALE, col:'rgba(255,255,200,0.9)' });
  }
  function emitBubble(x, y, str) {
    const buoy = 60 * theme.phys.buoyancy;
    const wobble = 1.2 * theme.phys.wobble;
    const allife = (1.6+Math.random()*1.0)*(0.7+str*0.6);
    const r = (8+Math.random()*8)*SCALE;
    addEnt({ m:'bubble', x,y, vx:(Math.random()*40-20)*SCALE, vy:-(40+Math.random()*40)*SCALE,
             t:0, life:allife, r, wobble, buoy, col:'rgba(200,240,255,0.85)', popped:false });
  }
  function emitShards(x, y, str) {
    const n = 8 + (str*8|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'shard', x,y,t:0, life:2.0, ang:Math.random()*Math.PI*2,
               len:(60+Math.random()*80)*SCALE, w:(4+Math.random()*6)*SCALE,
               col:'rgba(180,230,255,0.9)' });
  }
  function emitDust(x, y, str) {
    const n = 24 + (str*28|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'dust', x:x+(Math.random()*60-30), y:y+(Math.random()*60-30), t:0, life:2.5,
               vx:(Math.random()*50-25), vy:(Math.random()*50-25),
               s:(1.0+Math.random()*1.0)*SCALE, col:'rgba(210,220,255,0.9)' });
  }
  function emitComet(x, y, str) {
    addEnt({ m:'comet', x,y,t:0, life:1.5, vx:(160+Math.random()*100), vy:(Math.random()*80-40),
             len:(100+Math.random()*120)*SCALE, col:'rgba(120,200,255,0.95)' });
  }
  function emitWave(x, y, str) {
    for (let i=0;i<3;i++)
      addEnt({ m:'wave', x,y,t:0, life:2.0, r:(90+Math.random()*150)*SCALE,
               col:'rgba(170,220,255,0.75)' });
  }
  function emitPetalRain(x, y, str) {
    const n = 6 + (str*10|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'petalFall', x:x+(Math.random()*40-20), y:y+(Math.random()*20-10), t:0, life:3.0,
               vx:(Math.random()*40-20), vy:(20+Math.random()*40),
               w:(12+Math.random()*4)*SCALE, h:(20+Math.random()*8)*SCALE,
               rot:(Math.random()*2-1), col:`hsl(${(i*40)%360} 70% 75%)` });
  }
  function emitConfetti(x, y, str) {
    const n = 12 + (str*18|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'confetti', x,y,t:0, life:1.5, vx:(Math.random()*280-140), vy:(Math.random()*280-140),
               s:(5+Math.random()*3)*SCALE, rot:(Math.random()*6-3),
               col:`hsl(${(i*18+Math.random()*30)%360} 85% 65%)` });
  }
  function emitInkSwirl(x, y, str) {
    addEnt({ m:'ink', x,y,t:0, life:2.5, r:(70+Math.random()*70)*SCALE, col:'rgba(170,200,255,0.20)' });
  }
  function emitLava(x, y, str) {
    const n = 10 + (str*12|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'lava', x,y,t:0, life:1.8, vx:(Math.random()*280-140), vy:-(40+Math.random()*100),
               g:980*0.0016*theme.phys.gravity, col:'rgba(255,170,70,0.95)' });
  }
  function emitSnow(x, y, str) {
    const n = 6 + (str*8|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'snow', x:x+(Math.random()*40-20), y:y-10, t:0, life:3.0,
               vy:(20+Math.random()*20), wx:(0.6+Math.random()*0.6)*theme.phys.wind,
               r:(2.5+Math.random()*1.5)*SCALE, col:'rgba(255,255,255,0.92)' });
  }
  function emitAuroraCurtain(x, y, str) {
    addEnt({ m:'auroraCurtain', x,y,t:0, life:3.0, w:(160+Math.random()*120)*SCALE,
             amp:(12+Math.random()*10)*SCALE, freq:(0.006+Math.random()*0.006),
             col:'rgba(160,255,220,0.45)' });
  }
  function emitFireworks(x, y, str) {
    const n = 40 + (str*40|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'fw', x,y,t:0, life:2.0, vx:(Math.random()*440-220), vy:(Math.random()*440-220),
               col:`hsl(${(i*9)%360} 100% 65%)` });
  }
  function emitElectric(x, y, str) {
    addEnt({ m:'arc', x,y,t:0, life:0.6, seg:6+(str*4|0), len:(120+Math.random()*80)*SCALE,
             col:'rgba(180,220,255,0.95)' });
  }
  function emitCrystalRings(x, y, str) {
    const n = 2 + (str*2|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'ring', x,y,t:0, life:2.0, r0:10*SCALE, r1:(140+Math.random()*120)*SCALE,
               lw:2.0*SCALE, col:'rgba(190,240,255,0.85)' });
  }
  function emitButterfly(x, y, str) {
    const n = 4 + (str*4|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'butter', x,y,t:0, life:2.5, vx:(40+Math.random()*40), vy:(Math.random()*60-30),
               flap:(4+Math.random()*3), col:`hsl(${200+Math.random()*120} 70% 70%)` });
  }
  function emitSand(x, y, str) {
    const n = 18 + (str*22|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'sand', x:x+(Math.random()*16-8), y:y+(Math.random()*16-8), t:0, life:2.5,
               vy:(30+Math.random()*30), col:'rgba(230,210,160,0.9)', s:(1+Math.random())*SCALE });
  }
  function emitMeteor(x, y, str) {
    const n = 4 + (str*6|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'meteor', x,y,t:0, life:1.8, vx:(200+Math.random()*140), vy:(120+Math.random()*80),
               len:(100+Math.random()*100)*SCALE, col:'rgba(200,220,255,0.9)' });
  }
  function emitLeaves(x, y, str) {
    const n = 6 + (str*8|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'leaf', x:x+(Math.random()*20-10), y:y-10, t:0, life:3.0,
               vy:(20+Math.random()*25), wx:(0.8+Math.random()*0.5), rot:(Math.random()*2-1),
               w:(14+Math.random()*6)*SCALE, h:(18+Math.random()*8)*SCALE,
               col:`hsl(${20+Math.random()*40} 70% 55%)` });
  }
  function emitFoam(x, y, str) {
    const n = 14 + (str*14|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'foam', x:x+(Math.random()*36-18), y:y+(Math.random()*16-8), t:0, life:2.0,
               r:(4+Math.random()*6)*SCALE, col:'rgba(255,255,255,0.75)' });
  }
  function emitRainbow(x, y, str) {
    const n = 16 + (str*20|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'spark', x,y,t:0, life:1.2, vx:(Math.random()*240-120), vy:(Math.random()*240-120),
               s:(1.2+Math.random()*0.8)*SCALE, col:`hsl(${(i*20)%360} 90% 60%)` });
  }
  function emitPlasma(x, y, str) {
    const n = 3 + (str*3|0);
    for (let i=0;i<n;i++)
      addEnt({ m:'orb', x,y,t:0, life:3.0, r:(10+Math.random()*8)*SCALE, pulse:(3+Math.random()*3),
               col:'rgba(160,220,255,0.7)' });
  }
  /* Draw & update all entities */
  function drawEntities(dt){
    const mul = speedMul, fadeMul = theme.phys.fade;

    for (let i = ents.length - 1; i >= 0; i--) {
      const e = ents[i];
      e.t += dt * mul;
      const life = e.life || 1;
      const k = clamp01(e.t / life);
      const fade = Math.pow(1 - k, 1.15 * fadeMul);
      if (k >= 1) { ents.splice(i,1); continue; }

      // defaults
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';

      switch (e.m) {
        case 'ring': {
          const rr = e.r0 + (e.r1 - e.r0) * k;
          ctx.globalAlpha = 0.35 * fade;
          ctx.strokeStyle = e.col; ctx.lineWidth = e.lw || 1.6;
          ctx.beginPath(); ctx.arc(e.x, e.y, rr, 0, Math.PI*2); ctx.stroke();
        } break;

        case 'puff': {
          const rr = e.r * (0.4 + 0.6*k);
          ctx.globalAlpha = 0.5 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, rr, 0, Math.PI*2); ctx.fill();
        } break;

        case 'spark': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.85 * fade; ctx.fillStyle = e.col || '#fff';
          const s = e.s || 1.6;
          ctx.fillRect(e.x - s/2, e.y - s/2, s, s);
        } break;

        case 'glow': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.55 * fade; ctx.fillStyle = e.col;
          const r = (e.r || 3.5) * (1 + 0.5*Math.sin(e.t*6));
          ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.fill();
        } break;

        case 'petal': case 'petalFall': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          e.rot = (e.rot||0) + 0.8*dt*mul;
          const w = e.w||12, h = e.h||22;
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.rotate(e.rot);
          ctx.globalAlpha = 0.85 * fade;
          ctx.fillStyle = e.col || 'rgba(255,180,200,0.9)';
          ctx.beginPath();
          ctx.moveTo(0, -h*0.5);
          ctx.bezierCurveTo(w*0.6, -h*0.2,  w*0.6, h*0.2,  0, h*0.5);
          ctx.bezierCurveTo(-w*0.6, h*0.2, -w*0.6,-h*0.2, 0,-h*0.5);
          ctx.fill();
          ctx.restore();
        } break;

        case 'bubble': {
          // buoyancy & wobble
          e.vy -= (e.buoy||60) * dt * mul * 0.3;
          e.x += (e.vx||0)*dt*mul + Math.sin(e.t*2)*(e.wobble||1.2)*2;
          e.y += (e.vy||0)*dt*mul;
          ctx.globalAlpha = 0.35 * fade;
          ctx.strokeStyle = e.col; ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.arc(e.x, e.y, e.r||10, 0, Math.PI*2); ctx.stroke();
          ctx.globalAlpha = 0.12 * fade; ctx.fillStyle = '#9fdcff';
          ctx.beginPath(); ctx.arc(e.x- (e.r||10)*0.4, e.y- (e.r||10)*0.4, (e.r||10)*0.35, 0, Math.PI*2); ctx.fill();
        } break;

        case 'shard': {
          const len = e.len||100, w = e.w||6;
          e.x += Math.cos(e.ang||0) * 120 * dt * mul;
          e.y += Math.sin(e.ang||0) * 120 * dt * mul;
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.rotate(e.ang||0);
          ctx.globalAlpha = 0.6 * fade;
          ctx.fillStyle = e.col;
          ctx.fillRect(0, -w/2, len, w);
          ctx.restore();
        } break;

        case 'dust': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalAlpha = 0.5 * fade; ctx.fillStyle = e.col;
          const s = e.s || 1.6;
          ctx.beginPath(); ctx.arc(e.x, e.y, s, 0, Math.PI*2); ctx.fill();
        } break;

        case 'comet': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.9 * fade; ctx.strokeStyle = e.col;
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(e.x - (e.len||160), e.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        } break;

        case 'wave': {
          const rr = (e.r||150) * (0.3 + 0.7*k);
          ctx.globalAlpha = 0.28 * fade; ctx.strokeStyle = e.col;
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(e.x, e.y, rr, 0, Math.PI*2); ctx.stroke();
        } break;

        case 'ink': {
          const rr = e.r||140;
          ctx.globalAlpha = 0.18 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, rr*(0.35+0.65*k), 0, Math.PI*2); ctx.fill();
        } break;

        case 'lava': {
          e.vy += (e.g||980*0.0016)*dt*mul;
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.9 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, 3.2, 0, Math.PI*2); ctx.fill();
        } break;

        case 'snow': {
          e.x += Math.sin(e.t*3)*(e.wx||1.0)*10 * dt * mul;
          e.y += (e.vy||30) * dt * mul;
          ctx.globalAlpha = 0.9 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, e.r||3, 0, Math.PI*2); ctx.fill();
        } break;

        case 'auroraLine': {
          const len = e.len||200, amp = e.amp||16, freq = e.freq||0.012;
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.globalAlpha = 0.7 * fade; ctx.strokeStyle = e.col; ctx.lineWidth = 2;
          ctx.beginPath();
          for(let s=0;s<=1;s+=0.02){
            const xx = -len/2 + len*s;
            const yy = Math.sin((s*30 + e.t*4)*freq*500)*amp;
            if (s===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
          }
          ctx.stroke(); ctx.restore();
        } break;

        case 'auroraCurtain': {
          const w = e.w||220, amp=e.amp||18, freq=e.freq||0.008;
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.globalAlpha = 0.45 * fade; ctx.fillStyle = e.col;
          ctx.beginPath();
          for(let s=0;s<=1;s+=0.02){
            const xx = -w/2 + w*s;
            const yy = Math.sin((s*40 + e.t*3)*freq*500)*amp;
            if (s===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
          }
          ctx.lineTo(w/2, amp*2); ctx.lineTo(-w/2, amp*2); ctx.closePath(); ctx.fill();
          ctx.restore();
        } break;

        case 'fw': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.8 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, 2.2, 0, Math.PI*2); ctx.fill();
        } break;

        case 'arc': {
          const seg = e.seg||8, len=e.len||160;
          ctx.save(); ctx.translate(e.x, e.y);
          ctx.globalAlpha = 0.95 * fade; ctx.strokeStyle = e.col; ctx.lineWidth = 2;
          ctx.beginPath();
          let px = 0, py = 0; ctx.moveTo(px,py);
          for (let s=1; s<=seg; s++){
            const nx = (len/seg)*s;
            const ny = (Math.random()*30 - 15);
            ctx.lineTo(nx, ny); px=nx; py=ny;
          }
          ctx.stroke(); ctx.restore();
        } break;

        case 'star': {
          const d = (e.dist||180) * k;
          ctx.globalAlpha = 0.9 * fade; ctx.fillStyle = e.col;
          const x = e.x + Math.cos(e.ang||0)*d;
          const y = e.y + Math.sin(e.ang||0)*d;
          ctx.beginPath(); ctx.arc(x, y, 2.4, 0, Math.PI*2); ctx.fill();
        } break;

        case 'rain': {
          e.vy += (e.g||980*0.0016)*dt*mul;
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          ctx.globalAlpha = 0.9 * fade; ctx.strokeStyle = e.col; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(e.x, e.y - (e.len||22)); ctx.lineTo(e.x, e.y); ctx.stroke();
        } break;

        case 'meteor': {
          e.x += (e.vx||240)*dt*mul; e.y += (e.vy||160)*dt*mul;
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.9 * fade; ctx.strokeStyle = e.col; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(e.x - (e.len||160), e.y - (e.len||160)*0.3);
          ctx.lineTo(e.x, e.y); ctx.stroke();
        } break;

        case 'leaf': {
          e.x += Math.sin(e.t*2)*(e.wx||1.0)*10 * dt * mul;
          e.y += (e.vy||30) * dt * mul;
          e.rot = (e.rot||0) + 0.6*dt*mul;
          ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.rot);
          ctx.globalAlpha = 0.9 * fade; ctx.fillStyle = e.col;
          const w=e.w||16, h=e.h||22;
          ctx.beginPath();
          ctx.moveTo(0,-h/2);
          ctx.quadraticCurveTo(w/2,0,0,h/2);
          ctx.quadraticCurveTo(-w/2,0,0,-h/2);
          ctx.fill(); ctx.restore();
        } break;

        case 'foam': {
          ctx.globalAlpha = 0.6 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, e.r||6, 0, Math.PI*2); ctx.fill();
        } break;

        case 'confetti': {
          e.x += (e.vx||0)*dt*mul; e.y += (e.vy||0)*dt*mul;
          e.rot = (e.rot||0) + 1.2*dt*mul;
          ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.rot);
          ctx.globalAlpha = 0.9 * fade; ctx.fillStyle = e.col;
          const s = e.s || 6;
          ctx.fillRect(-s/2, -s/2, s, s);
          ctx.restore();
        } break;

        case 'orb': {
          const r = (e.r||14)*(1+0.25*Math.sin(e.t*(e.pulse||4)));
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.5 * fade; ctx.fillStyle = e.col;
          ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.fill();
        } break;
      }
    }

    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
  }

  /* Trails (for draw mode) */
  const paths = [];
  const TRAIL_LIFE = 4.2, TRAIL_W = 12;
  let timeNow = 0;

  function makePath(id,x,y){
    const p = { id, pts:[{x,y,t:timeNow}], dead:false };
    paths.push(p); return p;
  }
  function addPoint(p,x,y){
    const pts=p.pts, last=pts[pts.length-1];
    if (Math.hypot(x-last.x, y-last.y) < 2) return;
    pts.push({x,y,t:timeNow});
  }
  function endPath(p){
    p.dead = true;
    if (!drawMode) return;
    schedulePathPlayback(p, effectSel ? effectSel.value : 'softRipples');
  }

  function drawPaths(){
    if (!drawMode) return;
    ctx.lineCap='round'; ctx.lineJoin='round';
    for (let i=paths.length-1;i>=0;i--){
      const p=paths[i], pts=p.pts;
      while (pts.length && timeNow - pts[0].t > TRAIL_LIFE) pts.shift();
      if (pts.length<=1 && p.dead){ paths.splice(i,1); continue; }

      for (let j=0;j<pts.length-1;j++){
        const a=pts[j], b=pts[j+1];
        const age = timeNow - a.t;
        const alpha = Math.max(0, 1 - age/TRAIL_LIFE);
        if (alpha<=0) continue;

        ctx.globalAlpha = 0.45 * Math.pow(alpha, 1.1);
        ctx.strokeStyle = 'rgba(210,230,255,0.9)';
        const w = SCALE * (TRAIL_W * (0.32 + (1 - alpha) * 1.35));
        ctx.lineWidth = w;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;
  }

  /* Path playback (runs 3√ó after drawing) */
  const pathRuns = [];
  function clonePts(pts){ return pts.map(p=>({x:p.x,y:p.y,t:p.t})); }
  function buildGeom(pts){
    const cum=[0];
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      cum.push(cum[i-1]+Math.hypot(dx,dy));
    }
    return { cum, length: cum[cum.length-1] };
  }
  function sampleAlong(run,s01){
    const { pts, geom } = run;
    const L = geom.length;
    if (L<=0 || pts.length<2) return pts[0];
    const target = s01 * L;
    let i = run.idx || 0;
    while (i < pts.length-2 && geom.cum[i+1] < target) i++;
    run.idx = i;
    const a = pts[i], b = pts[i+1];
    const segStart = geom.cum[i];
    const segLen = Math.max(1e-6, geom.cum[i+1]-segStart);
    const u = (target - segStart) / segLen;
    return { x: a.x + (b.x-a.x)*u, y: a.y + (b.y-a.y)*u };
  }
  function schedulePathPlayback(path, effectName){
    const pts = clonePts(path.pts);
    if (pts.length < 2) return;
    const geom = buildGeom(pts);
    if (geom.length < 2) return;
    const speedPx = 500;
    pathRuns.push({ pts, geom, effect: effectName, s:0, prevS:0, idx:0, repeats:3, speedPx });
  }
  function runPathEffects(dt){
    for (let i=pathRuns.length-1;i>=0;i--){
      const run = pathRuns[i];
      const L = run.geom.length;
      if (L<=0){ pathRuns.splice(i,1); continue; }
      const ds = (run.speedPx * speedMul * dt) / L;
      let nextS = run.s + ds;
      const step = Math.max(0.002, 8 / L);

      for (let s = run.s; s < nextS; s += step){
        const pt = sampleAlong(run, Math.min(1, s));
        spawnAt(run.effect, pt.x, pt.y, 0.9);
      }
      run.prevS = run.s; run.s = nextS;

      if (run.s >= 1){
        run.repeats -= 1;
        if (run.repeats <= 0){ pathRuns.splice(i,1); continue; }
        run.s = 0; run.prevS = 0; run.idx = 0;
      }
    }
  }
  /* Spawn controller */
  const effectSel = document.getElementById('effectSel');
  function spawnAt(effect, x, y, velNorm){
    const s = Math.min(1.6, (velNorm==null?1:velNorm) * 1.8);
    switch (effect) {
      case 'softRipples':    emitSoftRipples(x,y,s); break;
      case 'floralBurst':    emitFloralBurst(x,y,s); break;
      case 'dissolvePuff':   emitDissolve(x,y,s); break;
      case 'sparkleTrail':   emitSparkle(x,y,s); break;
      case 'fireflies':      emitFireflies(x,y,s); break;
      case 'auroraLine':     emitAuroraLine(x,y,s); break;
      case 'smokeDrift':     emitSmoke(x,y,s); break;
      case 'rain':           emitRain(x,y,s); break;
      case 'starBurst':      emitStarBurst(x,y,s); break;
      case 'bubbles':        emitBubble(x,y,s); break;
      case 'crystalShards':  emitShards(x,y,s); break;
      case 'galaxyDust':     emitDust(x,y,s); break;
      case 'neonComet':      emitComet(x,y,s); break;
      case 'waveBloom':      emitWave(x,y,s); break;
      case 'petalRain':      emitPetalRain(x,y,s); break;
      case 'confetti':       emitConfetti(x,y,s); break;
      case 'inkSwirl':       emitInkSwirl(x,y,s); break;
      case 'lavaSparks':     emitLava(x,y,s); break;
      case 'snowfall':       emitSnow(x,y,s); break;
      case 'auroraCurtain':  emitAuroraCurtain(x,y,s); break;
      case 'fireworks':      emitFireworks(x,y,s); break;
      case 'electricArcs':   emitElectric(x,y,s); break;
      case 'crystalRings':   emitCrystalRings(x,y,s); break;
      case 'butterfly':      emitButterfly(x,y,s); break;
      case 'sandDrift':      emitSand(x,y,s); break;
      case 'meteorShower':   emitMeteor(x,y,s); break;
      case 'leavesFall':     emitLeaves(x,y,s); break;
      case 'oceanFoam':      emitFoam(x,y,s); break;
      case 'rainbowSparks':  emitRainbow(x,y,s); break;
      case 'plasmaOrbs':     emitPlasma(x,y,s); break;
      default:               emitSoftRipples(x,y,s);
    }
  }

  /* Input state (pointer events handle mouse + touch) */
  const pointers = new Map();
  const speedMulGetter = window.__CE_STATE__?.speedMulRef || (()=>1);
  function now(){ return performance.now(); }

  function startPointer(id, x, y){
    const o = { x, y, t: now(), path: drawMode ? makePath(id, x, y) : null, lastVel: 0 };
    pointers.set(id, o);
    spawnAt(effectSel.value, x, y, 0.2);
  }
  function movePointer(id, x, y){
    if (!pointers.has(id)) return;
    const P = pointers.get(id), t = now();
    const dt = Math.max(1, t - P.t);
    const dx = x - P.x, dy = y - P.y, dist = Math.hypot(dx, dy);
    const vel = dist / (dt / 1000), velNorm = Math.min(1.3, vel / 1200);
    const steps = Math.max(1, Math.min(40, Math.floor(dist / 3.3)));

    for (let i=1;i<=steps;i++){
      const u=i/steps, ex=P.x+dx*u, ey=P.y+dy*u;
      if (P.path) addPoint(P.path, ex, ey);
      spawnAt(effectSel.value, ex, ey, velNorm);
    }
    P.x = x; P.y = y; P.t = t; P.lastVel = velNorm;
  }
  function endPointer(id){
    const P = pointers.get(id);
    if (!P) return;
    if (P.path) endPath(P.path);
    pointers.delete(id);
  }
  function pos(e){
    return {
      x: e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0,
      y: e.clientY ?? (e.touches && e.touches[0]?.clientY) ?? 0
    };
  }

  /* Pointer bindings (work for mouse + touch) */
  addEventListener('pointerdown', e=>{
    if ((e.target).closest('.dock')) return;
    const p = pos(e);
    startPointer(e.pointerId, p.x, p.y);
    e.preventDefault();
  }, { passive:false, capture:true });

  addEventListener('pointermove', e=>{
    if ((e.target).closest('.dock')) return;
    if (e.buttons === 0) return;
    const p = pos(e);
    movePointer(e.pointerId, p.x, p.y);
    e.preventDefault();
  }, { passive:false, capture:true });

  addEventListener('pointerup', e=>{
    endPointer(e.pointerId);
    e.preventDefault();
  }, { passive:false, capture:true });

  addEventListener('pointercancel', e=>{
    endPointer(e.pointerId);
    e.preventDefault();
  }, { passive:false, capture:true });
  /* Main loop */
  let last = performance.now();
  function loop(nowTS){
    const dt = Math.min(.05, Math.max(.008, (nowTS - last) / 1000));
    last = nowTS;
    timeNow += dt * speedMul;

    bg();
    drawEntities(dt);
    drawPaths();
    runPathEffects(dt);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  /* Recorder */
  const recBtn  = document.getElementById('recBtn');
  const recLabel= document.getElementById('recLabel');
  const recTime = document.getElementById('recTime');
  const dlBtn   = document.getElementById('dlBtn');
  const openBtn = document.getElementById('openBtn');

  let recorder=null, chunks=[], recTimer=null, recStart=0, lastUrl=null;
  const MAX_REC_SEC = 10;

  function fmtTime(t){
    const mm = Math.floor(t/60);
    const ss = Math.floor(t%60);
    const ds = Math.floor((t%1)*10);
    const pad = n => String(n).padStart(2,'0');
    return `${pad(mm)}:${pad(ss)}.${ds}`;
  }
  function clearOldUrl(){
    if (lastUrl){ URL.revokeObjectURL(lastUrl); lastUrl=null; }
  }

  function startRec(){
    try{
      const stream = cvs.captureStream(60);
      const mime =
        (window.MediaRecorder && MediaRecorder.isTypeSupported?.('video/webm;codecs=vp9')) ? 'video/webm;codecs=vp9' :
        (window.MediaRecorder && MediaRecorder.isTypeSupported?.('video/webm;codecs=vp8')) ? 'video/webm;codecs=vp8' :
        'video/webm';

      recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
      chunks = [];
      clearOldUrl();
      if (dlBtn)   dlBtn.style.display   = 'none';
      if (openBtn) openBtn.style.display = 'none';

      recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: recorder.mimeType || mime });
        clearOldUrl();
        lastUrl = URL.createObjectURL(blob);
        if (dlBtn){ dlBtn.href = lastUrl; dlBtn.style.display = 'inline-flex'; }
        if (openBtn){ openBtn.href = lastUrl; openBtn.style.display = 'inline-flex'; }
        if (recLabel) recLabel.textContent = 'Record';
      };

      recorder.start();
      recStart = performance.now();
      if (recLabel) recLabel.textContent = 'Recording';
      if (recBtn)   recBtn.textContent   = 'Stop';

      recTimer = setInterval(()=>{
        const t = (performance.now() - recStart)/1000;
        const shown = Math.min(t, MAX_REC_SEC);
        if (recTime) recTime.textContent = fmtTime(shown);
        if (t >= MAX_REC_SEC) stopRec();
      }, 100);

    }catch(err){
      console.error('Recorder start failed:', err);
      if (recLabel) recLabel.textContent = 'Record';
      if (recBtn)   recBtn.textContent   = 'Record';
      alert('Recording needs a secure context. Please open this file via https or http://localhost/');
    }
  }

  function stopRec(){
    try{
      if (recTimer){ clearInterval(recTimer); recTimer = null; }
      if (recorder && recorder.state !== 'inactive') recorder.stop();
    } finally {
      recorder = null;
      if (recBtn) recBtn.textContent = 'Record';
    }
  }

  if (recBtn){
    recBtn.onclick = () => {
      if (!recorder) startRec();
      else stopRec();
    };
  }
})(); 
</script>
</body>
</html>


